// Generated by CoffeeScript 1.10.0
(function() {
//  var app = angular.module("slider", []);
  angular.module('aon.range.slider', [ 'ngCookies' ]);

  angular.module('aon.range.slider')
  .directive("slider", function($document, $timeout, $rootScope) {
    return {
      restrict: "E",
      scope: {
        model: "=",
        property: "@",
        step: "@",
        initFlg: '=initFlg',
        pointData: '=pointData',
        callback: '&receiveCallback',
        applyCallback: '&applyCallback'
      },
      replace: true,
      template: '<div class="slider-control">\n<div class="slider"><span class="scale"><i>10</i></span><span class="scale"><i>20</i></span><span class="scale"><i>30</i></span><span class="scale"><i>40</i></span><span class="scale"><i>50</i></span><span class="scale"><i>60</i></span><span class="scale"><i>70</i></span><span class="scale"><i>80</i></span><span class="scale"><i>90</i></span>\n</div>\n</div>',
      /**
       * directive link
       * 
       * @param {any} scope
       * @param {any} element
       * @param {any} attrs
       */
      link: function(scope, element, attrs) {
        var fn, getP, handles, i, j, len, mv, pTotal, ref, setP, calcP, initHandle, resultDisp, resultHide, step, updatePositions, equal;
        element = element.children();
        element.css('position', 'relative');
        handles = [];
        pTotal = 0;
        ref = scope.model;
//        equal = attrs.equal;
        equal = 1;

        /**
         * step 계산
         * 
         * @returns
         */
        step = function() {
          if ((scope.step != null)) {
            return parseFloat(scope.step);
          } else {
            return 0;
          }
        };

        /**
         * position get
         * 
         * @param {any} i
         * @returns
         */
        getP = function(i) {
          if (scope.property != null) {
            return scope.model[i][scope.property];
          } else {
            return scope.model[i];
          }
        };

        /**
         * position set
         * 
         * @param {any} i
         * @param {any} p
         * @returns
         */
        setP = function(i, p) {
          var s;
          s = step();
          if (s > 0) {
            //p = Math.round(p / s) * s;
        	  p = Math.floor(p / s) * s;
          }

          if (scope.property != null) {
            return scope.model[i][scope.property] = p;
          } else {
            return scope.model[i] = p;
          }
        };

        var totalSum = 0;
        for(var i = 0; i < scope.model.length; i++){
          totalSum += scope.model[i];
        }

        /**
         * 이후 핸들 위치값 계산
         * 
         * @param {any} idx
         * @param {any} dp
         */
        calcP = function(idx, dp){
          var leftDt = 0;
          var rightDt = 0;
          for(i = 0; i < scope.model.length; i++){
            if(i <= idx){
              leftDt += scope.model[i];
            } else {
              rightDt += scope.model[i];
            }
          }
          var currDt = (totalSum - leftDt) / ((scope.model.length - 1) - idx);
          var newIdx = idx+1;
          for(j = newIdx; j < scope.model.length; j++){
            scope.model[j] = currDt;
          }
        };

        /**
         * 핸들 초기화
         */
        initHandle = function(){
          $(element[0]).find('div.slider-handle').remove();
        };

        /**
         * 결과 보기 개발 및 디버깅용
         */
        resultDisp = function(){

          scope.pointData = [];
          var resultHtml = '';
          var correctionPoint = 0;
          var pointArray = new Array();
          var pointInfo = new Object();

          for(var idx = 0; idx < scope.model.length; idx++){
            tmp = $('#point').val() * (Math.floor(scope.model[idx]) / 100);
            pointInfo = new Object();
            pointInfo.order = (idx+1);
            pointInfo.value = Math.floor(tmp);

            pointArray.push(pointInfo);
            scope.$apply(function(){
              scope.pointData.push(pointInfo);
            });

            resultHtml += '* ' + pointInfo.order + ' ' + i18n.getLang('point', 'rank') + ' : ' + pointInfo.value + ' point<br>';
            correctionPoint += tmp;
          }

          resultHtml += '--------------------------------------------------<br>';
          resultHtml += '* ' + i18n.getLang('point', 'compensatePoint') + ' : ' + correctionPoint + ' point<br>';
          resultHtml += '* ' + i18n.getLang('point', 'returnPoint') + ' : ' + (parseInt($('#point').val()) - correctionPoint) + ' point<br>';

          var totalInfo = new Object();
          totalInfo.data = pointArray;
          totalInfo.correction = correctionPoint;
          totalInfo.return = (parseInt($('#point').val()) - correctionPoint);
          totalInfo.pointSimple = $('#point').val();
          totalInfo.chooseCount = $('#member').val();

          var totalData = JSON.stringify(totalInfo);

          $('.exOutput').text(totalData);
          $('#output').html(resultHtml);
          $('.output').show();

          $('#pointRatio').val(totalData);
        };
        
        /*
         * 결과 세팅
         */
        setResult = function(){
        	scope.pointData = [];
            var resultHtml = '';
            var correctionPoint = 0;
            var pointArray = new Array();
            var pointInfo = new Object();
            
            var titleVal = '';
            if($('#title').val() != undefined){
            	titleVal = $('#title').val();
            }

            for(var idx = 0; idx < scope.model.length; idx++){
              tmp = $('#point').val() * (Math.floor(scope.model[idx]) / 100);
              pointInfo = new Object();
              pointInfo.order = (idx+1);
              pointInfo.value = Math.floor(tmp);

              pointArray.push(pointInfo);
              scope.$apply(function(){
                scope.pointData.push(pointInfo);
              });

              correctionPoint += tmp;
            }

            var totalInfo = new Object();
            totalInfo.data = pointArray;
            totalInfo.correction = correctionPoint;
            totalInfo.returnPoint = (parseInt($('#point').val()) - correctionPoint);
            totalInfo.pointSimple = $('#point').val();
            totalInfo.chooseCount = $('#member').val();

            var totalData = JSON.stringify(totalInfo);

//            $('#pointRatio').val(totalData);
            scope.callback({data:pointArray, correction:correctionPoint, returnPoint:(parseInt($('#point').val()) - correctionPoint), title:titleVal, pointSimple:$('#point').val(), chooseCount:$('#member').val(), equal:equal});
        };

        /**
         * 결과 감추기
         */
        resultHide = function(){
          $('.output').hide();
        };

        /**
         * handle position update
         * 
         * @returns
         */
        updatePositions = function() {
          //initTemp();
          var handle, i, j, len, p, pRunningTotal, results, x;
          pTotal = scope.model.reduce(function(sum, item, i) {
            return sum + getP(i);
          }, 0);
          pRunningTotal = 0;
          results = [];
          for (i = j = 0, len = handles.length; j < len; i = ++j) {
            handle = handles[i];
            p = getP(i);
            pRunningTotal += p;
            x = pRunningTotal / pTotal * 100;
            results.push(handle.css({
              left: x + "%",
              top: "-30px"
              // top: "-" + handle.prop("clientHeight") / 2 + "px"
            }));
          }

          return results;
        };

        /**
         * 모델에 percent 값 update
         */
        updatePercent = function(){
//          var percentHandles = angular.element('.slider-handle');
          var percentHandles = $(element).find('.slider-handle');
          for(var i = 0; i < scope.model.length; i++){
            $(percentHandles[i]).text(Math.floor(scope.model[i]));
          }
        };

        //ref = scope.model;
        /**
         * 핸들 추가
         * 
         * @param {any} mv
         * @param {any} i
         * @returns
         */
        fn = function(mv, i) {
          var handle, startPleft, startPright, startX;
          if (i === scope.model.length - 1) {
            return;
          }
          handle = angular.element('<div class="slider-handle">'+mv+'</div>');
          handle.css("position", "absolute");
          handles.push(handle);
          element.append(handle);
          startX = 0;
          startPleft = startPright = 0;
          return handle.on("mousedown", function(event) {
            var mousemove, mouseup;
            mousemove = (function(_this) {
              return function(event) {
//                return $rootScope.safeApply(function() {
            	return scope.$applyAsync(function(){
                  var dp;
                  dp = (event.screenX - startX) / element.prop("clientWidth") * pTotal;
                  if (dp < -startPleft || dp > startPright) {
                    return;
                  }
                  setP(i, startPleft + dp);
                  //setP(i + 1, startPright - dp);
                  calcP(i, dp);
                  updatePercent();
                  resultHide();
                  equal = 0;
                  // $(handle).text(Math.floor(startPleft + dp));
                  return updatePositions();
                });
              };
            })(this);
            /**
             * 
             * 
             * @returns
             */
            mouseup = function() {
//              console.log(i);
//              console.log(scope.model[i]);
//              console.log(Math.floor(scope.model[i]));
//              console.log($('#point').val() * (Math.floor(scope.model[i]) / 100));
              var targetPoint = $('#point').val() * (Math.floor(scope.model[i]) / 100);
              var targetMessage = (i+1) +'등의 상금은 ' + targetPoint + '포인트 입니다.';
              $('.mpb_message span').text(targetMessage);
              
              $document.unbind("mousemove", mousemove);
              return $document.unbind("mouseup", mouseup);
            };
            event.preventDefault();
            startX = event.screenX;
            startPleft = getP(i);
            startPright = getP(i + 1);
            $document.on("mousemove", mousemove);
            return $document.on("mouseup", mouseup);
          });
        };

        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          mv = ref[i];
          fn(mv, i);
        }

        //return scope.$watch("model", updatePositions, true);
        scope.$watch('model', function(newValue, oldValue){
          if(newValue.length == $('#member').val() && newValue.length != 0){
            if(!scope.initFlg){
              initHandle();
              handles = [];
              pTotal = 0;
              totalSum = 0;

              for(var i = 0; i < scope.model.length; i++){
                totalSum += scope.model[i];
              }
              for (i = j = 0, len = scope.model.length; j < len; i = ++j) {
                mv = scope.model[i];
                fn(mv, i);
              }
              scope.initFlg = true;
            }
          }
          updatePositions();
        }, true);

        //dev 단계 결과 보여주기
//        $('#btnResult').off().on('click', function(){
//          resultDisp();
//        });

        $('#point, #member').off().on('keyup', function(){
//          resultHide();
        	initHandle();
        	if($('#point').val() == ''){
        		//console.log('포인트와 명수는 필수입력사항입니다.');
        		swal('Caution!', '포인트와 명수는 필수입력사항입니다.', 'warning');
        		$('#point').focus();
        	} else {
        		if($('#member').val == '1'){	//1명에게 분배
        			$('.mbp_message').show();
        		} else {	//다수에게 분배
        			var targetMessage = '채택(평점) 순위에 따라 차등지급을 원할 경우 아래 화살표를 움직여서 금액을 배분하세요.';
        			$('.mpb_message span').text(targetMessage);
        			scope.applyCallback();
        		}
        	}
        });
        
        //callback을 이용한 결과값 전달 
        $('#btnRegist').off().on('click', function(){
        	setResult();
        	return false;
        });

      }
    };
  })
  .directive('numChk', function(){
	  var linker = function(scope, element, attrs){ 
		  //keyup 이벤트 바인딩
		  element.off().on('keyup', function(){
			  scope.$apply(function(){
				  scope.tmpVal = element.val();
			  });
		  });
	  };
	  
	  var controller = function($scope){
		  //값 저장을 위한 임시 모델
		  $scope.tmpVal = '';
		  //정규식 패턴
		  $scope.chkPattern = /^[0-9]*$/;
		  
		  //값 변경에 따른 패턴 분석과 값 갱신
		  $scope.$watch('tmpVal', function(newValue, oldValue){
			  if(!$scope.chkPattern.test(newValue)){
				  $scope.$applyAsync(function(){
					  $scope.tmpVal = oldValue;
				  });
			  } else {
				  $scope.$applyAsync(function(){
					  $scope.tmpVal = newValue;
				  });
			  }
		  });
	  };
	  
	  return{
		  restrict: 'AE',
		  scope: true,
		  link: linker,
		  controller: controller
	  };
  });

//  app.controller("Ctrl", function($scope) {
//
//    /**
//     * scope 변수 초기화
//     */
//    $scope.init = function(){
//      
//    };
//
//    $scope.initFlg = false;
//
//    /**
//     * 분배 적용 버튼 이벤트
//     * 
//     * @returns
//     */
//    $scope.distribution = function(){
//      var point = $('#point').val();
//      var member = $('#member').val();
//
//      // 인원 10명 이상일때 문구
//      if(member > 10){
//        //toastr.warning('포인트 분배 인원은 최대 10명입니다.');
//        swal('Caution!', '포인트 분배 인원은 최대 10명입니다.', 'warning');
//        return false;
//      } else {
//        $('#slider-area').show();
//        $('.btn-area').show();
//        
//        // var result = member+'명에게 '+(point / member)+'포인트씩 지급됩니다.';
//        // $('#output').text(result);
//        // $('.output').show();
//
//        $scope.$apply(function(){
//          $scope.initFlg = false;
//          $scope.otherProbs = [];
//        });
//
//        var result2 = 100 / member;
//        for(var i = 0; i < member; i++){
//          $scope.$apply(function(){
//            $scope.otherProbs.push(result2);
//          });
//        }
//
//        console.log($scope.otherProbs);
//      }
//    };
//
//    /**
//     * 결과보기 버튼 이벤트
//     */
//    $scope.viewResult = function(){
//      console.log('result');
//      $('.output').show();
//    };
//
//    // 슬라이드 좌표를 위한 퍼센트 모델
//    //$scope.otherProbs = [20, 20, 20, 20, 20];
//    $scope.otherProbs = [];
//
//    // backend로 전달할 포인트를 분배한 실제 모델
//    $scope.pointData = [];
//
//    $scope.init();
//
//  });

}).call(this);
